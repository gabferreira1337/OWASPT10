# SQL Injection (SQLi)
***
### **SQL injection** (**SQLi**) is a cybersecurity thread wherein an attacker manipulates the input fields of a web application to inject malicious SQL code into the database queries. By doing this so, the attacker can gain unauthorized access to sensitive date, modify or delete records, and potentially compromise the entire application or server. 
## Types of SQL injection:
1. **In-Band (Classic)** : In-band SQL injection is a type of attack where a malicious actor can inject and execute SQL commands using the same pathway used for legitimate communication with a database. Essentially, the attacker can both launch the attack and retrieve the results through the same route. 
   * **Error** : Error-based SQL injection is a type of SQL injection attack where an attacker exploits errors generated by a database to gather information about the structure and content of the database.
     * Example:
       * Input:  `www.asd1337.org/app.php?uid='`   
       * Output: `You have an error in your SQL syntax, check the manual that corresponds to your MySQL server version...` 
   * **Union** : Union-based SQL injection is a type of SQL injection attack where an attacker exploits the UNION SQL operator to combine the results of the original SQL query with the results of another query crafted by the attacker.
     * Example: 
       * Input:  `www.asd1337.org/app.php?uid=' UNION SELECT username, password FROM users--` \  
       * Output: `admin ksdlsanalflafna`
   * Example:
       * Input: ```  www.asd1337.org/app.php?uid=1'; DROP TABLE users```
2. **Blind**
    * **Boolean** :
    * **Time** :
3. **Out-of-Band** : Out-of-band SQL injection is used when we don't have direct access to the output whatsoever, so we may need to direct the output to a remote location (out-of-band) 'i.e., DNS record' and then attempt to retrieve it from there.
## Detecting SQL injection vulnerabilities
#### To detect SQLi vulnerabilities in a web application, a systematic set of tests can be conducted on each entry point by following manual testing methods or use automated tools like Burp Scanner
### Manual Testing:
1. Single Quote Test:
   * Test with : 
     * `'`      or `%27`  (url encoded)
     * `"`      or `%22`  
     * `#`      or `%23`  
     * `;`      or `%3B`  
     * `)`      or `%29` 
   * to identify potential errors or anomalies in the application's response. If there's an error or unexpected behavior, it could indicate a potential SQLi vulnerability.
   * **Note** that in some cases, we may have to use the URL encoded version of the payload as seen on the list above. An example os this is when we put our payload in the URL
   
2. SQL Syntax Testing:
   * Test SQL-specific syntax to evaluate the original value and a different value. Check for systematic differences in the application's responses.
3. Boolean Conditions:
   * Use boolean conditions like `OR 1=1` and `OR 1=2` to check for differences in the application's responses.
4. Time-Based Testing:
   * Inject payloads design to trigger time delays in SQL queries. Monitor the application's response times for variations, indicating a potential time-based blind SQLi.
5. Out-of-Band (**OAST**) testing:
   * Inject payloads that trigger out-of-band network interactions within SQL queries. Monitor and analyze any resulting network interaction. 
#### Automated testing (Burp Scanner):
1. Configuration:
   * Set up **Burp Scanner** and configure it to scan the target application.
2. Scan parameters:
   * Specify the parameters and entry points to be scanned within the application.
3. Scan Initiation:
   * Start the scanning process, and **Burp Scanner** will automatically inject various payloads, analyze responses, and identify potential SQli vulnerabilities.

#### Injecting a ' or a " escapes the limits of user input, so it does not get executed as simple user input
#### While using those special characters we need to make sure that no syntax error occurs on the back-end because of the last trailing character. That's why in most cases we use comments ("--") or using multiple single quotes (').
***
### 3 Measures to prevent SQL injections
* **Parameterized Queries**: Utilizing parameterized queries, or prepared statements, is crucial for preventing SQL injection vulnerabilities. By parameterizing user input, the query structure remains intact, and potential malicious input is treated as data rather than executable code.
* **Comprehensive Application of Parameterized Queries**: Parameterized queries should be applied consistently across all instances where untrusted input is involved in SQL queries, such as the **WHERE** clause or values in **INSERT** or **UPDATE** statements. However, caution is advised when dealing with other query components, like table or column names or the **ORDER BY** clause, wich require alternative security measures 
* **Whitelisting**: Identifying and approving only certain characters, patterns, or values that are allowed in user inputs. Also Whitelisting may include the use of escape characters or encoding to neutralize any attemp to exploit the input with characters that have special meaning in SQL.
***
### [SQL injection cheat sheet from portswigger](https://portswigger.net/web-security/sql-injection/cheat-sheet)
### [SQL injection Payloads](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/SQL%20Injection/README.md)